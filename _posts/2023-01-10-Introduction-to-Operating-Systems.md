---
title:  "[운영체제] Introduction to Operating Systems"
excerpt: "운영체제의 정의, 목적, 분류, 구조와 예시"

categories:
  - OS
tags:
  - [OS]
  
toc: true
toc_sticky: true
 
date: 2023-01-10T12:48:05-04:00
last_modified_at: 2023-01-10T08:48:05-04:00
---

# Introduction to Operating Systems

> - 이 글은 이화여자대학교 반효경 교수님의 '운영체제' 강의(2014년 1학기)를 학습한 내용을 정리한 것입니다.

## 운영체제(Operating System, OS)란?

- 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층

  ![post-thumbnail](https://velog.velcdn.com/images/thalals/post/d83834b5-1cbf-4f0f-9e73-8eaa9835fcd2/image.png)

- **협의의 운영체제(커널)**

  - 운영체제의 핵심 부분으로 메모리에 상주하는 부분

- **광의의 운영체제**

  - 커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념

## 운영체제의 목적

- 컴퓨터 시스템의 자원을 효율적으로 관리
  - 프로세서, 기억장치, 입출력 장치 등의 효율적 관리
    - 사용자 간의 형평성 있는 자원 분배
    - 주어진 자원으로 최대한의 **성능**을 내도록 함
  - 사용자 및 운영체제 자신의 보호
  - 소프트웨어 자원(프로세스, 파일, 메시지) 등을 관리
- 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
  - 운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상을 제공
  - 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행

## 운영 체제의 분류

- 분류 기준
  - 동시 작업 가능 여부
  - 사용자의 수
  - 처리 방식

### - 동시 작업 가능 여부

- **단일 작업(single tasking)**

  - 한 번에 하나의 작업만 처리

    ex) MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령 수행 불가

- **다중 작업(multi tasking)**

  - 동시에 두 개 이상의 작업 처리

    ex) UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음

### - 사용자의 수(여러 사용자 계정을 만들어 동시 접근을 할 수 있는지)

- **단일 사용자(single user)**

  ​		ex) MS-DOS, MS Windows

- **다중 사용자(multi user)**

  - 한 사람이 여러 프로그램을 동시에 실행할 수 있으면(시분할) 하나의 컴퓨터에서 여러 명이 동시에 작업할 수 있음

  - 사용자가 많으면 사용자의 파일, 메모리 접근 등을 다른 사용자가 보지 못하게 하는 보안 기능 등이 추가되어야 함

    ex) UNIX, NT server

### - 처리 방식

- **일괄 처리(batch processing)**

  ![image](https://user-images.githubusercontent.com/45728407/153217823-1155f29c-2cce-4cd4-8cf7-b956b1ec758a.png)

  - 작업 요청의 일정량 모아서 한꺼번에 처리

  - 작업이 완전 종료될 때까지 기다려야 함

  - 현대의 운영체제에서는 찾아보기 어려운 방식

    ex) 초기 Punch Card 처리 시스템

- **시분할(time sharing)**

  ![image](https://user-images.githubusercontent.com/45728407/153218903-b95c521a-b504-4642-8b42-9dc181f894c3.png)

  - 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용

  - 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐

    - 단, 자원을 최대한 활용하는 것이 목적이기 때문에 실시간과 달리 시간에 대한 제약 조건이 있진 않음. 사용자가 늘어나면 처리 시간이 점점 늘어남

    ex) UNIX

  - Interactive한 방식

    - 입력에 대한 출력이 빠르게 이루어지므로 사용자는 interactive하다는 인상을 받음

  - 일반적으로 사용되는 OS의 처리 방식은 시분할에 해당함

    ​		ex) Linux, Windows, iOS, Android 등

  - 내비게이션, 블랙박스 등 데드라인 준수가 중요한 애플리케이션이 늘어나고 있기 때문에 범용 운영체제가 실시간성을 어떻게 지켜줄 수 있는지가 근래 화두임

- **실시간(realtime OS)**

  - 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS

  - 작업이 완료되어야 하는 데드라인

  - 기존에는 특수한 목적을 가진 시스템에서 주로 사용되었으나, 최근에는 보다 완화된 개념으로 사용됨

    ex) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어

  - 실시간 시스템의 개념 확장

    - **Hard realtime system(경성 실시간 시스템)**

      - 데드라인을 정확하게 지키지 않으면 치명적인 결과를 초래

        ex) 벽을 뚫고 나서 폭발하는 스마트 미사일

    - **Soft realtime system(연성 실시간 시스템)**

      - 데드라인이 조금 어긋나더라도 치명적인 결과를 초래하진 않음

        ex) 동영상 플레이어

### - 몇 가지 용어 정리

- **Multitasking**
  - 매 순간에는 하나의 작업만 실행되지만 시간을 짧은 간격으로 분할하여 할당하므로 여러 작업이 동시에 실행되는 것처럼 보임
  - 하나의  프로그램이 끝나기 전에 다른 프로그램을 실행 가능
- **Multiprogramming**
  - 메모리에 여러 프로그램이 동시에 올라가는 측면을 강조한 표현
- **Time sharing**
  - CPU의 시간을 분할하여 나누어 쓴다는 점을 강조한 표현
- **Multiprocess**
- 구분
  - 위의 용어들은 컴퓨터에서 여러 작업을 동시에 수행하는 것을 뜻함
- **Multiprocessor**
  - 하나의 컴퓨터에 CPU(processor)가 여러 개 붙어있음을 의미
  - 위의 용어들이 CPU가 하나만 있더라도 시간을 나누어 동시에 실행이 가능한 시스템을 의미하는 반면 Multiprocessor는 CPU가 여러 개 있는 하드웨어적으로 다른 시스템임(단, Multiprocessor의 CPU도 Multitasking을 지원)

## 운영체제의 예

- UNIX는 대형 컴퓨터를 위해 만들어진 반면, Windows 계열의 운영체제는 개인용 컴퓨터(PC)를 위해 만들어짐
- **유닉스(UNIX)**
  - 코드의 대부분을 C언어로 작성
    - 기계어에 가까운 어셈블리 언어로 운영체제를 만들려면 코드가 복잡했으므로, 유닉스를 만들 때 C언어라는 프로그래밍 언어를 새로 만듦
    - 유닉스는 대부분의 커널 코드가 C언어로 작성되어 있음
    - 오늘날에도 시스템 소프트웨어를 만들 때 기본적으로 C언어를 사용함
  - 높은 이식성
    - 하나의 컴퓨터에서 돌아가는 유닉스를 기계어 집합이 전혀 다른 컴퓨터에 이식하기 쉬움
  - 최소한의 커널 구조
    - 핵심적인 기능만 커널에 집어넣음
  - 복잡한 시스템에 맞게 확장 용이
  - 소스 코드 공개
    - 반면, Windows의 경우 소스코드가 공개되어 있지 않고, 컴파일한 결과물만을 판매함
  - 프로그램 개발에 용이
  - 다양한 버전
    - System V, FreeBSD, SunOS, Solaris
    - Linux
      - 공개 소프트웨어 정신에 입각해 소스코드를 공개하는 UNIX 계열의 운영체제
      - 초기 유닉스는 서버에 설치하여 여러 사용자가 접속해 사용하게끔 설계된 운영체제였는데, Linux는 개인용 컴퓨터에 설치해 사용하기에도 적합함
      - Android도 운영체제 커널은 Linux 커널을 사용함
- **DOS(디스크 운영체제, Disk Operating System)**
  - 흔히 MS사에서 만든 MS-DOS를 지칭하지만, 본래 디스크 운영 체제를 포괄하는 표현
  - MS 사에서 1981년 IBM-PC를 위해 개발
  - 단일 사용자용 운영체제, 메모리 관리 능력의 한계(주 기억 장치: 640KB)
    - 초창기에는 PC가 용량이 작고 단일 프로그램만 지원이 됐음
  - 하드웨어 발전에 따라 이를 보완하기 위한 코드가 더해지면서 DOS는 
  - MS-DOS는 1995년 개발이 중단
- **MS Windows**
  - MS사의 다중 작업용 GUI 기반 운영 체제
  - 3.1까지는 MS-DOS 상에서 실행하는 응용 프로그램이었지만, 시간이 흐르며 독자적인 운영체제로 자리잡음 
  - Plug and Play(PnP), 네트워크 환경 강화
    - 컴퓨터에 프린터 등의 주변 기기를 연결하면 별도의 사용자 조작이나 프로그램 설치 없이 바로 사용할 수 있는 것
      - DOS 시절에는 주변 기기를 연결하면 사용자가 직접 부팅 시 환경 설정을 하고 드라이버 소프트웨어를 설치해야 했음
    - 나아가 1999년에는 각종 주변 기기를 가정의 네트워크에 접속해 공유할 수 있게 하는 **Universal Plug and Play(UPnP)**가 등장함
      - 일반 기기들이 고유의 IP 주소를 가지고 TCP/IP 등의 인터넷 프로토콜을 이용해 통신
      - PnP를 홈 네트워크에서도 적용할 수 있게 한 것
  - DOS용 응용 프로그램과 호환성 제공
  - 불안정성
    - 초창기에는 불안정했으나 많이 해소됐음
  - 풍부한 지원 소프트웨어
- **Handheld device를 위한 OS**
  - PalmOS, Pocket PC(WinCE), Tiny OS

## 운영체제의 구조

<img src="C:\Users\jodic\AppData\Roaming\Typora\typora-user-images\image-20230128144353482.png" alt="image-20230128144353482" style="zoom: 67%;" />

- 운영체제는 Disk, Memory, CPU 사이의 시간 차이를 완충해주고 주어진 자원의 특성을 최대한 활용하는 방향으로 발전해옴

- CPU 스케줄링: 누구한테 CPU를 줄까?

- **메모리 관리**: 한정된 메모리를 어떻게 쪼개어 쓰지?

  -  무조건 균등하게 메모리를 할당하기보다 상황에 따라 특정 작업들에 메모리를 몰아줌
  -  과거에 많이 사용되었으므로 앞으로도 많이 사용될 것으로 예측되는 데이터를 메모리에 올리고 그 외에는 디스크로 내리는 방식

- **파일 관리**: 디스크에 파일을 어떻게 보관하지?

  - 디스크의 특성에 맞게 파일을 관리

  - 디스크 스케줄링

    - HDD의 경우, 어떻게 하면 움직임을 최소화하면서 많은 요청을 처리할 수 있는가

    - 엘리베이터 스케줄링과 비슷

      ex) 헤드가 움직이면서 데이터를 읽고 쓰는 경우, 헤드로부터 가까운 위치의 요청이 들어왔다면 나중에 들어왔더라도 먼저 처리

- **입출력 관리**: 각기 다른 입출력장치와 컴퓨터 간에 어떻게 정보를 주고 받게 하지?

  - I/O device는 CPU에 비해 현저하게 느리기 때문에 Interrupt를 활용함
    - I/O device가 Interrupt를 걸면 CPU는 다음 작업을 처리하기 전에 I/O device의 요청을 처리

- **프로세스 관리**

  - 앞서 나온 하드웨어가 아닌 프로그램들을 어떻게 관리할 것인가

## 참고

-범용 플러그앤플레이

http://terms.tta.or.kr/dictionary/dictionaryView.do?subject=%EB%B2%94%EC%9A%A9+%ED%94%8C%EB%9F%AC%EA%B7%B8+%EC%95%A4+%ED%94%8C%EB%A0%88%EC%9D%B4
